rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Protect user profiles - only the user can access their profile
    match /users/{userId} {
      // Users can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;

      // Users can update their profile, but cannot modify protected fields
      allow update: if request.auth != null &&
                      request.auth.uid == userId &&
                      // Prevent modification of critical fields
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'emailVerified', 'id', 'createdAt']);

      // User creation is handled by Cloud Functions only
      // Cloud Functions use Admin SDK which bypasses these rules
      allow create: if false;

      // Users cannot delete their own profile
      allow delete: if false;
    }

    // Helper function to check if user has quiz access via share
    function hasQuizAccess(quizId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/quizzes/$(quizId)/shares/$(request.auth.token.email));
    }

    // CollectionGroup rule for querying shares across all quizzes
    match /{path=**}/shares/{shareId} {
      // Allow authenticated users to read shares where sharedWith matches their email
      allow read: if request.auth != null &&
                    resource.data.sharedWith == request.auth.token.email;
    }

    // Quizzes can be read by anyone, but only managed by their owner
    match /quizzes/{quizId} {
      allow read: if true;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.hostId;
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.hostId;

      // Quiz shares subcollection
      // Note: shareId is the email address for efficient exists() checks
      match /shares/{shareId} {
        // Owner can read all shares for their quiz
        // Recipient can read shares where sharedWith matches their email
        allow read: if request.auth != null &&
                      (request.auth.uid == get(/databases/$(database)/documents/quizzes/$(quizId)).data.hostId ||
                       request.auth.token.email == resource.data.sharedWith);

        // Only quiz owner can create shares
        // Document ID (shareId) must match the sharedWith email
        allow create: if request.auth != null &&
                        request.auth.uid == get(/databases/$(database)/documents/quizzes/$(quizId)).data.hostId &&
                        request.resource.data.sharedBy == request.auth.uid &&
                        request.resource.data.quizId == quizId &&
                        shareId == request.resource.data.sharedWith;

        // Owner can delete their shares, recipient can also delete (to cancel)
        allow delete: if request.auth != null &&
                        (request.auth.uid == resource.data.sharedBy ||
                         request.auth.token.email == resource.data.sharedWith);
      }
    }

    // Activities collection (for non-quiz activities like Interest Cloud)
    match /activities/{activityId} {
      // Anyone can read activity details (needed for players to see activity info)
      allow read: if true;

      // Only authenticated hosts can create activities
      allow create: if request.auth != null &&
                      request.auth.uid == request.resource.data.hostId;

      // Only the activity owner can update or delete
      allow update, delete: if request.auth != null &&
                              request.auth.uid == resource.data.hostId;
    }

    // Presentations collection (for hybrid presentations with interactive slides)
    match /presentations/{presentationId} {
      // Anyone can read presentation details (needed for players during game)
      allow read: if true;

      // Only authenticated hosts can create presentations
      allow create: if request.auth != null &&
                      request.auth.uid == request.resource.data.hostId;

      // Only the presentation owner can update or delete
      allow update, delete: if request.auth != null &&
                              request.auth.uid == resource.data.hostId;
    }

    // Templates collection (for user-created presentation templates)
    match /templates/{templateId} {
      // Users can read their own templates
      allow read: if request.auth != null &&
                    resource.data.createdBy == request.auth.uid;

      // Users can create templates with their own UID
      allow create: if request.auth != null &&
                      request.resource.data.createdBy == request.auth.uid &&
                      request.resource.data.isBuiltIn == false;

      // Users can update their own templates
      allow update: if request.auth != null &&
                      resource.data.createdBy == request.auth.uid &&
                      request.resource.data.createdBy == request.auth.uid;

      // Users can delete their own templates
      allow delete: if request.auth != null &&
                      resource.data.createdBy == request.auth.uid;
    }

    // Helper function to check if user owns a presentation
    function ownsPresentation(presentationId) {
      return request.auth != null &&
             request.auth.uid == get(/databases/$(database)/documents/presentations/$(presentationId)).data.hostId;
    }

    // Helper function to check if user owns an activity
    function ownsActivity(activityId) {
      return request.auth != null &&
             request.auth.uid == get(/databases/$(database)/documents/activities/$(activityId)).data.hostId;
    }

    // Game sessions
    match /games/{gameId} {
      // Anyone can read game state
      allow read: if true;

      // Authenticated hosts can create games:
      // - For quiz games: must own the quiz OR have shared access
      // - For activity games: must own the activity
      // - For presentation games: must own the presentation
      allow create: if request.auth != null &&
                      request.auth.uid == request.resource.data.hostId &&
                      (
                        // Quiz-based games (existing flow)
                        (request.resource.data.get('activityType', 'quiz') == 'quiz' &&
                         (request.auth.uid == get(/databases/$(database)/documents/quizzes/$(request.resource.data.quizId)).data.hostId ||
                          hasQuizAccess(request.resource.data.quizId)))
                        ||
                        // Activity-based games (Interest Cloud, Evaluation, etc.)
                        (request.resource.data.activityType in ['thoughts-gathering', 'evaluation'] &&
                         request.resource.data.activityId != null &&
                         ownsActivity(request.resource.data.activityId))
                        ||
                        // Presentation-based games
                        (request.resource.data.activityType == 'presentation' &&
                         request.resource.data.presentationId != null &&
                         ownsPresentation(request.resource.data.presentationId))
                      );

      // Only the host can update or delete the game
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.hostId;

      // Leaderboard, analytics, and answer key aggregates subcollection
      match /aggregates/{aggId} {
        // answerKey is NEVER readable by clients - only Cloud Functions (admin SDK)
        // This prevents players from seeing correct answers
        // Leaderboard readable by all (for gameplay)
        // Analytics only by host
        allow read: if aggId != 'answerKey' &&
                      (aggId != 'analytics' ||
                        (request.auth != null &&
                         request.auth.uid == get(/databases/$(database)/documents/games/$(gameId)).data.hostId));

        // Only the host can create/update aggregates (initialization from lobby)
        // Cloud Functions also update this using admin SDK
        allow create, update: if request.auth != null &&
                                 request.auth.uid == get(/databases/$(database)/documents/games/$(gameId)).data.hostId;

        // No client-side deletes - cleanup handled by Cloud Functions or game deletion
        allow delete: if false;
      }

      // Player data within a game
      match /players/{playerId} {
        // Anyone can read player data for leaderboards
        allow read: if true;

        // Only allow creating player with initial score of 0, empty answers, and streak 0
        allow create: if request.resource.data.score == 0 &&
                        request.resource.data.id == playerId &&
                        request.resource.data.name is string &&
                        request.resource.data.name.size() >= 2 &&
                        request.resource.data.name.size() <= 20 &&
                        request.resource.data.answers == [] &&
                        request.resource.data.currentStreak == 0;

        // All player updates (score, answers, streak) are handled by Cloud Functions only
        // Cloud Functions use admin privileges and bypass these rules
        allow update: if false;

        // Players cannot be deleted
        allow delete: if false;
      }

      // Submissions subcollection - used for:
      // 1. Quiz crowdsource questions (questionText, answers, correctAnswerIndex)
      // 2. Standalone Thoughts Gathering submissions (rawText)
      // 3. Presentation Thoughts slides (rawText + slideId)
      match /submissions/{submissionId} {
        // Anyone can read submissions (for display in lobby)
        allow read: if true;

        // Players can create submissions based on game type and state
        allow create: if request.resource.data.playerId is string &&
                         request.resource.data.playerName is string &&
                         (
                           // Quiz crowdsource submissions (existing validation)
                           (get(/databases/$(database)/documents/games/$(gameId)).data.get('activityType', 'quiz') == 'quiz' &&
                            get(/databases/$(database)/documents/games/$(gameId)).data.state == 'lobby' &&
                            get(/databases/$(database)/documents/games/$(gameId)).data.get('crowdsourceState', {'submissionsLocked': false}).submissionsLocked != true &&
                            request.resource.data.questionText is string &&
                            request.resource.data.questionText.size() >= 10 &&
                            request.resource.data.questionText.size() <= 500 &&
                            request.resource.data.answers.size() == 4 &&
                            request.resource.data.correctAnswerIndex >= 0 &&
                            request.resource.data.correctAnswerIndex <= 3)
                           ||
                           // Standalone Thoughts Gathering submissions (during collecting state)
                           (get(/databases/$(database)/documents/games/$(gameId)).data.activityType == 'thoughts-gathering' &&
                            get(/databases/$(database)/documents/games/$(gameId)).data.state == 'collecting' &&
                            request.resource.data.rawText is string &&
                            request.resource.data.rawText.size() >= 1 &&
                            request.resource.data.rawText.size() <= 1000)
                           ||
                           // Presentation thoughts slides (with slideId)
                           (get(/databases/$(database)/documents/games/$(gameId)).data.activityType == 'presentation' &&
                            get(/databases/$(database)/documents/games/$(gameId)).data.state == 'presenting' &&
                            request.resource.data.rawText is string &&
                            request.resource.data.rawText.size() >= 1 &&
                            request.resource.data.rawText.size() <= 1000 &&
                            request.resource.data.slideId is string)
                         );

        // Only host can update submissions (for AI evaluation results)
        allow update: if request.auth != null &&
                         request.auth.uid == get(/databases/$(database)/documents/games/$(gameId)).data.hostId;

        // Deletes handled by Cloud Functions (cleanup on game end/cancel)
        allow delete: if false;
      }

      // Evaluation items subcollection - items to be evaluated by participants
      match /items/{itemId} {
        // Anyone can read items (for display during evaluation)
        allow read: if true;

        // Host can create items OR players can submit items if allowed (during collecting state)
        allow create: if (
                         // Host can always create items for their game
                         (request.auth != null &&
                          request.auth.uid == get(/databases/$(database)/documents/games/$(gameId)).data.hostId)
                         ||
                         // Players can submit items during collecting state (no auth required)
                         (get(/databases/$(database)/documents/games/$(gameId)).data.activityType == 'evaluation' &&
                          get(/databases/$(database)/documents/games/$(gameId)).data.state == 'collecting' &&
                          request.resource.data.text is string &&
                          request.resource.data.text.size() >= 1 &&
                          request.resource.data.text.size() <= 500 &&
                          request.resource.data.isHostItem == false &&
                          request.resource.data.submittedByPlayerId is string)
                       );

        // Only host can update items (approve/reject, reorder)
        allow update: if request.auth != null &&
                         request.auth.uid == get(/databases/$(database)/documents/games/$(gameId)).data.hostId;

        // Only host can delete items
        allow delete: if request.auth != null &&
                         request.auth.uid == get(/databases/$(database)/documents/games/$(gameId)).data.hostId;
      }

      // Evaluation ratings subcollection - player ratings for items
      match /ratings/{ratingId} {
        // Anyone can read ratings (for host to see progress and for results)
        allow read: if true;

        // Players can create/update their own ratings (during rating state)
        // The ratingId should match the playerId
        allow create, update: if ratingId == request.resource.data.playerId &&
                                 request.resource.data.playerName is string &&
                                 get(/databases/$(database)/documents/games/$(gameId)).data.activityType == 'evaluation' &&
                                 get(/databases/$(database)/documents/games/$(gameId)).data.state == 'rating';

        // No client-side deletes
        allow delete: if false;
      }

      // Slide responses subcollection - for presentation rating/poll submissions
      // Document ID format: {slideId}_{playerId}
      match /slideResponses/{responseId} {
        // Anyone can read (for host to see results, players to see their own)
        allow read: if true;

        // Players can create their own responses during presentation
        allow create: if get(/databases/$(database)/documents/games/$(gameId)).data.activityType == 'presentation' &&
                         get(/databases/$(database)/documents/games/$(gameId)).data.state == 'presenting' &&
                         request.resource.data.playerId is string &&
                         request.resource.data.slideId is string &&
                         (
                           // Rating submissions (rating field present)
                           (request.resource.data.rating is number &&
                            request.resource.data.rating >= 1 &&
                            request.resource.data.rating <= 10)
                           ||
                           // Poll/other submissions (no rating field required)
                           request.resource.data.rating == null
                         );

        // Players can update their own response
        allow update: if request.resource.data.playerId == resource.data.playerId;

        // No client-side deletes
        allow delete: if false;
      }
    }
  }
}
